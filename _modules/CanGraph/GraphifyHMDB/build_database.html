
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CanGraph.GraphifyHMDB.build_database &#8212; CanGraph 1.0 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script src="../../../_static/design-tabs.js"></script>
    <link rel="shortcut icon" href="../../../_static/cangraph-mini.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../_static/cangraph-logo.png" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../index.html">
                    Main Page
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../Downloads.html">
   Downloads
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../Tutorials.html">
   Tutorials
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../Other%20Reading%20Material.html">
     Other Reading Material
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../Installing%20CanGraph.html">
     Installing CanGraph
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../Running%20the%20Software.html">
     Running the Software
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../Understanding%20its%20Outputs.html">
     Understanding its Outputs
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference external" href="https://www.pablomarcos.me/es/posts/master-en-biolog%c3%ada-computacional/tfm/">
   Presentations
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../CanGraph.html">
   CanGraph package
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../CanGraph.ExposomeExplorer.html">
     CanGraph.ExposomeExplorer package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../CanGraph.GraphifyDrugBank.html">
     CanGraph.GraphifyDrugBank package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../CanGraph.GraphifyHMDB.html">
     CanGraph.GraphifyHMDB package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../CanGraph.GraphifySMPDB.html">
     CanGraph.GraphifySMPDB package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../CanGraph.MeSHandMetaNetX.html">
     CanGraph.MeSHandMetaNetX package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../CanGraph.QueryWikidata.html">
     CanGraph.QueryWikidata package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../Install%20Apptainer.html">
     Install Apptainer
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../ToDoList.html">
   To-Do List
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Logo by <a href="https://www.instagram.com/danonino.caducado/"> Daniel Marcos </a> </br>
                     Website by <a href="https://www.pablomarcos.me/"> Pablo Marcos </a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/OMB-IARC/CanGraph/"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/OMB-IARC/CanGraph//issues/new?title=Issue%20on%20page%20%2F_modules/CanGraph/GraphifyHMDB/build_database.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for CanGraph.GraphifyHMDB.build_database</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1"># SPDX-FileCopyrightText: 2022 Pablo Marcos &lt;software@loreak.org&gt;</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier: MIT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A python module that provides the necessary functions to transition the HMDB database to graph format,</span>
<span class="sd">either from scratch importing all the nodes (as showcased in :obj:`CanGraph.GraphifyHMDB.main`) or in a case-by-case basis,</span>
<span class="sd">to annotate existing metabolites (as showcased in :obj:`CanGraph.main`).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Import external modules necessary for the script</span>
<span class="kn">from</span> <span class="nn">alive_progress</span> <span class="kn">import</span> <span class="n">alive_bar</span> <span class="c1"># A cute progress bar that shows the script is still running</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">shutil</span>               <span class="c1"># Vital modules to interact with the filesystem</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>               <span class="c1"># A hack to avoid starving the system resources</span>

<span class="c1"># Import subscripts for the program</span>
<span class="c1"># This hack that allows us to de-duplicate the miscleaneous script in this less-used script</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;../&quot;</span><span class="p">)</span>
<span class="c1"># .. NOTE:: Please beware that, if using this module by itself, you might need to copy &quot;miscelaneous.py&quot; into your path</span>
<span class="c1"># This is not the most elegant, but simplifies code maintenance, and this script shouldnt be used much so...</span>
<span class="kn">import</span> <span class="nn">miscelaneous</span> <span class="k">as</span> <span class="nn">misc</span>

<div class="viewcode-block" id="add_metabolites"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_metabolites">[docs]</a><span class="k">def</span> <span class="nf">add_metabolites</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates &quot;Metabolite&quot; nodes based on XML files obtained from the HMDB website,</span>
<span class="sd">    adding some essential identifiers and external properties.</span>

<span class="sd">    .. seealso:: This way of working has been taken from</span>
<span class="sd">        `William Lyon&#39;s Blog &lt;https://lyonwj.com/blog/grandstack-podcast-app-parsing-xml-neo4j-rss-episodes-playlists&gt;`_</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;metabolite&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;status&quot;][0]._text AS status,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;name&quot;][0]._text AS name,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;chemical_formula&quot;][0]._text AS chemical_formula,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;average_molecular_weight&quot;][0]._text AS average_molecular_weight,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;monisotopic_molecular_weight&quot;][0]._text AS monisotopic_molecular_weight,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;iupac_name&quot;][0]._text AS iupac_name,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;cas_registry_number&quot;][0]._text AS cas_registry_number,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;smiles&quot;][0]._text AS smiles,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;inchi&quot;][0]._text AS inchi,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;inchikey&quot;][0]._text AS inchikey,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;state&quot;][0]._text AS state,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;chemspider_id&quot;][0]._text AS chemspider_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;drugbank_id&quot;][0]._text AS drugbank_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;foodb_id&quot;][0]._text AS foodb_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;pubchem_compound_id&quot;][0]._text AS pubchem_compound_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;pdb_id&quot;][0]._text AS pdb_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;chebi_id&quot;][0]._text AS chebi_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;phenol_explorer_compound_id&quot;][0]._text AS phenol_explorer_compound_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;knapsack_id&quot;][0]._text AS knapsack_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;kegg_id&quot;][0]._text AS kegg_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;biocyc_id&quot;][0]._text AS biocyc_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;bigg_id&quot;][0]._text AS bigg_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;wikipedia_id&quot;][0]._text AS wikipedia_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;metlin_id&quot;][0]._text AS metlin_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;vmh_id&quot;][0]._text AS vmh_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;synthesis_reference&quot;][0]._text AS synthesis_reference,</span>

<span class="s2">            [X in metabolite._children WHERE X._type = &quot;secondary_accessions&quot;] AS secondary_accessions,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;synonyms&quot;] AS synonyms</span>

<span class="s2">        MERGE (m:Metabolite </span><span class="se">{{</span><span class="s2"> HMDB_ID:accession </span><span class="se">}}</span><span class="s2"> )</span>
<span class="s2">        SET m.Status = status, m.Name = name, m.Formula = chemical_formula,</span>
<span class="s2">            m.Average_Mass = average_molecular_weight, m.Monisotopic_Molecular_Weight = monisotopic_molecular_weight,</span>
<span class="s2">            m.IUPAC = iupac_name, m.CAS_Number = cas_registry_number, m.SMILES = smiles,</span>
<span class="s2">            m.InChI = inchi, m.InChIKey = inchikey, m.State = state, m.ChemSpider_ID = chemspider_id, m.DrugBank_ID = drugbank_id,</span>
<span class="s2">            m.FooDB_Compound_ID = foodb_id, m.PubChem_ID = pubchem_compound_id, m.PDB_ID = pdb_id, m.ChEBI_ID = chebi_id,</span>
<span class="s2">            m.Phenol_Explorer_Compound_ID = phenol_explorer_compound_id, m.KNApSAcK_ID = knapsack_id, m.KEGG_ID = kegg_id,</span>
<span class="s2">            m.Bigg_ID = bigg_id, m.WikiPedia_Article = wikipedia_id, m.METLIN_ID = metlin_id, m.VMH_ID = vmh_id</span>

<span class="s2">        WITH split(split(synthesis_reference, &quot;,&quot;)[-3], &quot;.&quot;)[-2] AS ref_title,</span>
<span class="s2">             secondary_accessions, synonyms, synthesis_reference, m</span>

<span class="s2">        FOREACH(ignoreMe IN CASE WHEN synthesis_reference IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            FOREACH(ignoreMe IN CASE WHEN ref_title IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">                MERGE (p:Publication </span><span class="se">{{</span><span class="s2"> Title: ref_title </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">                SET p.Authors = replace(split(synthesis_reference, &quot;. &quot;)[0], &quot;;&quot;,&quot;,&quot;)</span>
<span class="s2">                SET p.Publication = split(split(synthesis_reference, &quot;,&quot;)[-3], &quot;.&quot;)[-1]</span>
<span class="s2">                SET p.Date = replace(split(split(synthesis_reference, &quot;,&quot;)[-3], &quot;(&quot;)[1], &quot;)&quot;, &quot;&quot;)</span>
<span class="s2">                SET p.Volume = split(split(synthesis_reference, &quot;,&quot;)[-2], &quot;(&quot;)[0]</span>
<span class="s2">                SET p.Issue = replace(split(split(synthesis_reference, &quot;,&quot;)[-2], &quot;(&quot;)[1], &quot;)&quot;, &quot;&quot;)</span>
<span class="s2">                SET p.Pages = split(synthesis_reference, &quot;,&quot;)[-1]</span>

<span class="s2">                MERGE (m)-[r:CITED_IN]-&gt;(p)</span>
<span class="s2">                SET r.Type = &quot;Synthesis&quot;</span>
<span class="s2">            )</span>
<span class="s2">        )</span>

<span class="s2">        WITH secondary_accessions, synonyms, m</span>

<span class="s2">        SET m.Synonyms = &quot;&quot;, m.Secondary_HMDB_IDs = &quot;&quot;</span>
<span class="s2">        FOREACH(element in secondary_accessions|</span>
<span class="s2">            FOREACH(accession in element._children|</span>
<span class="s2">                SET m.Secondary_HMDB_IDs = accession._text + &quot;,&quot; + m.Secondary_HMDB_IDs</span>
<span class="s2">            )</span>
<span class="s2">        )</span>

<span class="s2">        FOREACH(element in synonyms|</span>
<span class="s2">            FOREACH(synonym in element._children|</span>
<span class="s2">                SET m.Synonyms = synonym._text + &quot;,&quot; + m.Synonyms</span>
<span class="s2">            )</span>
<span class="s2">        )</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_diseases"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_diseases">[docs]</a><span class="k">def</span> <span class="nf">add_diseases</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates &quot;Publication&quot; nodes based on XML files obtained from the HMDB website.</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. NOTE:: Here, an UNWIND clause is used instead of a FOREACH clause. This provides</span>
<span class="sd">        better performance, since, unlike FOREACH, UNWIND does not process rows with empty values</span>
<span class="sd">        (and, logically, there should be no Publication if there is no Disease)</span>

<span class="sd">    .. NOTE:: Publications are created with a (m)-[r:CITED_IN]-&gt;(p) relation with Metabolite nodes.</span>
<span class="sd">        If one wants to find the Publication nodes related to a given Metabolite/Disease relation,</span>
<span class="sd">        one can use:</span>

<span class="sd">        .. code-block:: python3</span>

<span class="sd">            MATCH p=()-[r:RELATED_WITH]-&gt;()</span>
<span class="sd">              WITH split(r.PubMed_ID, &quot;,&quot;) as pubmed</span>
<span class="sd">                UNWIND pubmed as find_this</span>
<span class="sd">                MATCH (p:Publication)</span>
<span class="sd">                  WHERE p.PubMed_ID = find_this</span>
<span class="sd">            RETURN p</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;metabolite&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>

<span class="s2">            [X in metabolite._children WHERE X._type = &quot;diseases&quot;] AS diseases</span>

<span class="s2">        MERGE (m:Metabolite </span><span class="se">{{</span><span class="s2">HMDB_ID:accession</span><span class="se">}}</span><span class="s2">)</span>

<span class="s2">        WITH diseases, m</span>
<span class="s2">        UNWIND diseases AS disease</span>
<span class="s2">        UNWIND disease[&quot;_children&quot;] AS my_disease</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in my_disease._children WHERE X._type = &quot;name&quot;][0]._text AS diseasename,</span>
<span class="s2">            [X in my_disease._children WHERE X._type = &quot;omin_id&quot;][0]._text AS omim_id,</span>
<span class="s2">            [X in my_disease._children WHERE X._type = &quot;references&quot;] AS references,</span>
<span class="s2">            m</span>

<span class="s2">        UNWIND references as reference</span>
<span class="s2">        WITH diseasename, omim_id, reference, m</span>
<span class="s2">        UNWIND reference[&quot;_children&quot;] AS my_reference</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in my_reference._children WHERE X._type = &quot;reference_text&quot;][0]._text AS reference_text,</span>
<span class="s2">            [X in my_reference._children WHERE X._type = &quot;pubmed_id&quot;][0]._text AS pubmed_id,</span>
<span class="s2">            diseasename, omim_id, m</span>

<span class="s2">        MERGE (d:Disease </span><span class="se">{{</span><span class="s2">Name:diseasename </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">        SET d.OMIM_ID = omim_id</span>

<span class="s2">        MERGE (m)-[r:ASSOCIATED_DISEASE_METABOLITE]-(d)</span>

<span class="s2">        WITH split(replace(reference_text, split(reference_text, &quot;:&quot;)[0]+&quot;: &quot;, &quot;&quot;), &quot;.&quot;)[0] AS ref_title,</span>
<span class="s2">             pubmed_id, reference_text, m</span>

<span class="s2">        FOREACH(ignoreMe IN CASE WHEN ref_title IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (p:Publication </span><span class="se">{{</span><span class="s2"> Title: ref_title </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            SET p.Authors = split(reference_text, &quot;:&quot;)[0]</span>


<span class="s2">            SET p.Publication = split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[0]</span>
<span class="s2">            SET p.Notes = split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[2]</span>
<span class="s2">            SET p.Date = split(split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[1],&quot;;&quot;)[0]</span>
<span class="s2">            SET p.Volume = split(split(reference_text, &quot;;&quot;)[1], &quot;(&quot;)[0]</span>
<span class="s2">            SET p.Issue = split(split(reference_text, &quot;(&quot;)[1], &quot;)&quot;)[0]</span>
<span class="s2">            SET p.Pages = split(split(reference_text, &quot;:&quot;)[-1], &quot;.&quot;)[0]</span>
<span class="s2">            SET p.PubMed_ID = pubmed_id</span>

<span class="s2">            MERGE (m)-[r2:CITED_IN]-&gt;(p)</span>
<span class="s2">            SET r2.PubMed_ID = &quot;&quot;</span>
<span class="s2">            SET r2.PubMed_ID = pubmed_id + &quot;,&quot; + r2.PubMed_ID</span>
<span class="s2">        )</span>
<span class="s2">        </span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_concentrations_normal"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_concentrations_normal">[docs]</a><span class="k">def</span> <span class="nf">add_concentrations_normal</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates &quot;Concentration&quot; nodes based on XML files obtained from the HMDB website.</span>
<span class="sd">    In this function, only metabolites that are labeled as &quot;normal_concentration&quot; are added.</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. NOTE:: Here, an UNWIND clause is used instead of a FOREACH clause. This provides</span>
<span class="sd">        better performance, since, unlike FOREACH, UNWIND does not process rows with empty values</span>

<span class="sd">    .. WARNING:: Using the CREATE row forces the creation of a Concentration node, even when</span>
<span class="sd">        some values might be missing. However, this means some bogus nodes could be added,</span>
<span class="sd">        which MUST be accounted for at the end of the DB-Creation process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;metabolite&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;normal_concentrations&quot;] AS normal_concentrations</span>

<span class="s2">        MERGE (m:Metabolite </span><span class="se">{{</span><span class="s2">HMDB_ID:accession</span><span class="se">}}</span><span class="s2">)</span>

<span class="s2">        WITH normal_concentrations, m</span>
<span class="s2">        UNWIND normal_concentrations AS normal_concentration</span>
<span class="s2">        WITH normal_concentration, m</span>
<span class="s2">        UNWIND normal_concentration[&quot;_children&quot;] AS my_concentrations</span>

<span class="s2">        WITH</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;_type&quot;][0]._text AS biospecimen,</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;concentration_value&quot;][0]._text AS value,</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;concentration_units&quot;][0]._text AS units,</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;subject_age&quot;][0]._text AS subject_age,</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;subject_sex&quot;][0]._text AS subject_sex,</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;subject_condition&quot;][0]._text AS subject_condition,</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;comment&quot;][0]._text AS comment,</span>

<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;references&quot;] AS references,</span>
<span class="s2">            m</span>

<span class="s2">        UNWIND references as reference</span>
<span class="s2">        WITH biospecimen, value, units, subject_age, subject_sex, subject_condition, reference,</span>
<span class="s2">             comment, m</span>
<span class="s2">        UNWIND reference[&quot;_children&quot;] AS my_reference</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in my_reference._children WHERE X._type = &quot;reference_text&quot;][0]._text AS reference_text,</span>
<span class="s2">            [X in my_reference._children WHERE X._type = &quot;pubmed_id&quot;][0]._text AS pubmed_id,</span>
<span class="s2">            biospecimen, value, units, subject_age, subject_sex, subject_condition, comment,</span>
<span class="s2">            m</span>

<span class="s2">        CREATE (c:Measurement </span><span class="se">{{</span><span class="s2">Normal:&quot;True&quot;</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">        SET c.Value = value, c.Comments = comment</span>

<span class="s2">        CREATE (sb:Subject)</span>
<span class="s2">        SET sb.Age = replace(subject_age, &quot;&amp;gt;&quot;, &quot;&gt;&quot;),</span>
<span class="s2">            sb.Gender = replace(subject_sex, &quot;Both&quot;, &quot;Female + Male&quot;),</span>
<span class="s2">            sb.Information = subject_condition</span>

<span class="s2">        MERGE (m)-[r5:MEASURED_AS]-&gt;(c)</span>
<span class="s2">        MERGE (c)-[r7:TAKEN_FROM_SUBJECT]-&gt;(sb)</span>

<span class="s2">        FOREACH(ignoreMe IN CASE WHEN units IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE  (un:Unit </span><span class="se">{{</span><span class="s2">Name:units</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (c)-[r6:MEASURED_IN]-&gt;(un)</span>
<span class="s2">            )</span>
<span class="s2">        FOREACH(ignoreMe IN CASE WHEN biospecimen IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE  (bs:BioSpecimen </span><span class="se">{{</span><span class="s2">Name:biospecimen</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (c)-[r8:FOUND_IN]-&gt;(bs)</span>
<span class="s2">            )</span>

<span class="s2">        SET r5.PubMed_ID = &quot;&quot;</span>
<span class="s2">        SET r5.PubMed_ID = pubmed_id + &quot;,&quot; + r5.PubMed_ID</span>

<span class="s2">        WITH split(replace(reference_text, split(reference_text, &quot;:&quot;)[0]+&quot;: &quot;, &quot;&quot;), &quot;.&quot;)[0] AS ref_title,</span>
<span class="s2">        pubmed_id, reference_text, c</span>

<span class="s2">        FOREACH(ignoreMe IN CASE WHEN ref_title IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (p:Publication </span><span class="se">{{</span><span class="s2"> Title: ref_title </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            SET p.Authors = split(reference_text, &quot;:&quot;)[0]</span>


<span class="s2">            SET p.Publication = split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[0]</span>
<span class="s2">            SET p.Notes = split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[2]</span>
<span class="s2">            SET p.Date = split(split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[1],&quot;;&quot;)[0]</span>
<span class="s2">            SET p.Volume = split(split(reference_text, &quot;;&quot;)[1], &quot;(&quot;)[0]</span>
<span class="s2">            SET p.Issue = split(split(reference_text, &quot;(&quot;)[1], &quot;)&quot;)[0]</span>
<span class="s2">            SET p.Pages = split(split(reference_text, &quot;:&quot;)[-1], &quot;.&quot;)[0]</span>
<span class="s2">            SET p.PubMed_ID = pubmed_id</span>

<span class="s2">            MERGE (c)-[r2:CITED_IN]-&gt;(p)</span>
<span class="s2">        )</span>

<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_concentrations_abnormal"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_concentrations_abnormal">[docs]</a><span class="k">def</span> <span class="nf">add_concentrations_abnormal</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates &quot;Concentration&quot; nodes based on XML files obtained from the HMDB website.</span>
<span class="sd">    In this function, only metabolites that are labeled as &quot;abnormal_concentration&quot; are added.</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. NOTE:: Here, an UNWIND clause is used instead of a FOREACH clause. This provides</span>
<span class="sd">        better performance, since, unlike FOREACH, UNWIND does not process rows with empty values</span>

<span class="sd">    .. WARNING:: Using the CREATE row forces the creation of a Concentration node, even when</span>
<span class="sd">        some values might be missing. However, this means some bogus nodes could be added,</span>
<span class="sd">        which MUST be accounted for at the end of the DB-Creation process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;metabolite&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;abnormal_concentrations&quot;] AS abnormal_concentrations</span>

<span class="s2">        MERGE (m:Metabolite </span><span class="se">{{</span><span class="s2">HMDB_ID:accession</span><span class="se">}}</span><span class="s2">)</span>

<span class="s2">        WITH abnormal_concentrations, m</span>
<span class="s2">        UNWIND abnormal_concentrations AS abnormal_concentration</span>
<span class="s2">        WITH abnormal_concentration, m</span>
<span class="s2">        UNWIND abnormal_concentration[&quot;_children&quot;] AS my_concentrations</span>

<span class="s2">        WITH</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;_type&quot;][0]._text AS biospecimen,</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;concentration_value&quot;][0]._text AS value,</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;concentration_units&quot;][0]._text AS units,</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;patient_age&quot;][0]._text AS patient_age,</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;patient_sex&quot;][0]._text AS patient_sex,</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;patient_information&quot;][0]._text AS patient_information,</span>
<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;comment&quot;][0]._text AS comment,</span>

<span class="s2">            [X in my_concentrations._children WHERE X._type = &quot;references&quot;] AS references,</span>
<span class="s2">            m</span>

<span class="s2">        UNWIND references as reference</span>
<span class="s2">        WITH biospecimen, value, units, patient_age, patient_sex, patient_information, reference,</span>
<span class="s2">             comment, m</span>
<span class="s2">        UNWIND reference[&quot;_children&quot;] AS my_reference</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in my_reference._children WHERE X._type = &quot;reference_text&quot;][0]._text AS reference_text,</span>
<span class="s2">            [X in my_reference._children WHERE X._type = &quot;pubmed_id&quot;][0]._text AS pubmed_id,</span>
<span class="s2">            biospecimen, value, units, patient_age, patient_sex, patient_information, comment, m</span>

<span class="s2">        CREATE (c:Measurement </span><span class="se">{{</span><span class="s2">Normal:&quot;True&quot;</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">        SET c.Value = value, c.Comments = comment</span>

<span class="s2">        CREATE (sb:Subject)</span>
<span class="s2">        SET sb.Age = replace(patient_age, &quot;&amp;gt;&quot;, &quot;&gt;&quot;), sb.Gender = replace(patient_sex, &quot;Both&quot;, &quot;Female + Male&quot;), sb.Information = patient_information</span>

<span class="s2">        MERGE (m)-[r5:MEASURED_AS]-&gt;(c)</span>
<span class="s2">        MERGE (c)-[r7:TAKEN_FROM_SUBJECT]-&gt;(sb)</span>

<span class="s2">        FOREACH(ignoreMe IN CASE WHEN units IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE  (un:Unit </span><span class="se">{{</span><span class="s2">Name:units</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (c)-[r6:MEASURED_IN]-&gt;(un)</span>
<span class="s2">            )</span>
<span class="s2">        FOREACH(ignoreMe IN CASE WHEN biospecimen IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE  (bs:BioSpecimen </span><span class="se">{{</span><span class="s2">Name:biospecimen</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (c)-[r8:FOUND_IN]-&gt;(bs)</span>
<span class="s2">            )</span>

<span class="s2">        SET r5.PubMed_ID = &quot;&quot;</span>
<span class="s2">        SET r5.PubMed_ID = pubmed_id + &quot;,&quot; + r5.PubMed_ID</span>

<span class="s2">        WITH split(replace(reference_text, split(reference_text, &quot;:&quot;)[0]+&quot;: &quot;, &quot;&quot;), &quot;.&quot;)[0] AS ref_title,</span>
<span class="s2">            pubmed_id, reference_text, c</span>

<span class="s2">        FOREACH(ignoreMe IN CASE WHEN ref_title IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (p:Publication </span><span class="se">{{</span><span class="s2"> Title: ref_title </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            SET p.Authors = split(reference_text, &quot;:&quot;)[0]</span>


<span class="s2">            SET p.Publication = split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[0]</span>
<span class="s2">            SET p.Notes = split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[2]</span>
<span class="s2">            SET p.Date = split(split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[1],&quot;;&quot;)[0]</span>
<span class="s2">            SET p.Volume = split(split(reference_text, &quot;;&quot;)[1], &quot;(&quot;)[0]</span>
<span class="s2">            SET p.Issue = split(split(reference_text, &quot;(&quot;)[1], &quot;)&quot;)[0]</span>
<span class="s2">            SET p.Pages = split(split(reference_text, &quot;:&quot;)[-1], &quot;.&quot;)[0]</span>
<span class="s2">            SET p.PubMed_ID = pubmed_id</span>

<span class="s2">            MERGE (c)-[r2:CITED_IN]-&gt;(p)</span>
<span class="s2">        )</span>

<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_taxonomy"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_taxonomy">[docs]</a><span class="k">def</span> <span class="nf">add_taxonomy</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates &quot;Taxonomy&quot; nodes based on XML files obtained from the HMDB website.</span>
<span class="sd">    These represent the &quot;kind&quot; of metabolite we are dealing with (Family, etc)</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. NOTE:: It only creates relationships in the Kingdom -&gt; Super Class -&gt; Class -&gt; Subclass</span>
<span class="sd">        direction, and from any node -&gt; Metabolite. This means that, if any member of the</span>
<span class="sd">        Kingdom -&gt; Super Class -&gt; Class -&gt; Subclass is absent, the line will be broken; hopefully</span>
<span class="sd">        in that case a new metabolite will come in to rescue and settle the relation!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;metabolite&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;taxonomy&quot;] AS taxonomy</span>

<span class="s2">        MERGE (m:Metabolite </span><span class="se">{{</span><span class="s2">HMDB_ID:accession</span><span class="se">}}</span><span class="s2">)</span>

<span class="s2">        WITH taxonomy, m</span>
<span class="s2">        UNWIND taxonomy as my_nodes</span>

<span class="s2">        WITH</span>
<span class="s2">            [X IN my_nodes._children WHERE X._type = &quot;description&quot;][0]._text AS description,</span>
<span class="s2">            [X IN my_nodes._children WHERE X._type = &quot;direct_parent&quot;][0]._text AS direct_parent,</span>
<span class="s2">            [X IN my_nodes._children WHERE X._type = &quot;kingdom&quot;][0]._text AS kingdom,</span>
<span class="s2">            [X IN my_nodes._children WHERE X._type = &quot;super_class&quot;][0]._text AS super_class,</span>
<span class="s2">            [X IN my_nodes._children WHERE X._type = &quot;class&quot;][0]._text AS class,</span>
<span class="s2">            [X IN my_nodes._children WHERE X._type = &quot;sub_class&quot;][0]._text AS sub_class,</span>

<span class="s2">            [X IN my_nodes._children WHERE X._type = &quot;alternative_parents&quot;] AS alternative_parents,</span>
<span class="s2">            [X IN my_nodes._children WHERE X._type = &quot;substituents&quot;] AS substituents,</span>
<span class="s2">            [X IN my_nodes._children WHERE X._type = &quot;external_descriptors&quot;] AS external_descriptors,</span>
<span class="s2">            m</span>

<span class="s2">        SET m.Description = apoc.text.capitalize(description)</span>

<span class="s2">        // First, we create the Taxonomy nodes independently</span>

<span class="s2">        FOREACH(ignoreMe IN CASE WHEN kingdom IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (k:Taxonomy </span><span class="se">{{</span><span class="s2">Type:&quot;Kingdom&quot;, Name:kingdom</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">        )</span>
<span class="s2">        FOREACH(ignoreMe IN CASE WHEN super_class IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (sp:Taxonomy </span><span class="se">{{</span><span class="s2">Type:&quot;Super Class&quot;, Name:super_class</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">        )</span>
<span class="s2">        FOREACH(ignoreMe IN CASE WHEN class IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (c:Taxonomy </span><span class="se">{{</span><span class="s2">Type:&quot;Class&quot;, Name:class</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">        )</span>
<span class="s2">        FOREACH(ignoreMe IN CASE WHEN sub_class IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (sb:Taxonomy </span><span class="se">{{</span><span class="s2">Type:&quot;Sub Class&quot;, Name:sub_class</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">        )</span>
<span class="s2">        FOREACH(ignoreMe IN CASE WHEN direct_parent IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (dp:Taxonomy </span><span class="se">{{</span><span class="s2">Name:direct_parent</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (m)-[:PART_OF_CLADE]-&gt;(dp)</span>
<span class="s2">        )</span>

<span class="s2">        // Then, we add a hierarchy connecting the nodes as much as possible between them</span>

<span class="s2">        FOREACH(ignoreMe IN CASE WHEN kingdom IS NOT null AND super_class IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (k:Taxonomy </span><span class="se">{{</span><span class="s2"> Type:&quot;Kingdom&quot;, Name:kingdom </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (sp:Taxonomy </span><span class="se">{{</span><span class="s2"> Type:&quot;Super Class&quot;, Name:super_class </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (k)-[:PART_OF_CLADE]-&gt;(sp)</span>
<span class="s2">        )</span>
<span class="s2">        FOREACH(ignoreMe IN CASE WHEN class IS NOT null AND super_class IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (c:Taxonomy </span><span class="se">{{</span><span class="s2"> Type:&quot;Class&quot;, Name:class </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (sp:Taxonomy </span><span class="se">{{</span><span class="s2"> Type:&quot;Super Class&quot;, Name:super_class </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (sp)-[:PART_OF_CLADE]-&gt;(c)</span>
<span class="s2">        )</span>
<span class="s2">        FOREACH(ignoreMe IN CASE WHEN sub_class IS NOT null AND class IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (c:Taxonomy </span><span class="se">{{</span><span class="s2"> Type:&quot;Class&quot;, Name:class </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (sb:Taxonomy </span><span class="se">{{</span><span class="s2"> Type:&quot;Sub Class&quot;, Name:sub_class </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (sb)-[:PART_OF_CLADE]-&gt;(c)</span>
<span class="s2">        )</span>

<span class="s2">        // And we connect the hierarchy to the main node just once</span>

<span class="s2">        FOREACH(ignoreMe IN CASE WHEN sub_class IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (ta:Taxonomy </span><span class="se">{{</span><span class="s2"> Name:sub_class </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (m)-[:PART_OF_CLADE]-&gt;(ta)</span>
<span class="s2">        )</span>
<span class="s2">        FOREACH(ignoreMe IN CASE WHEN class IS NOT null</span>
<span class="s2">                AND sub_class IS null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (ta:Taxonomy </span><span class="se">{{</span><span class="s2"> Name:class </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (m)-[:PART_OF_CLADE]-&gt;(ta)</span>
<span class="s2">        )</span>
<span class="s2">        FOREACH(ignoreMe IN CASE WHEN super_class IS NOT null</span>
<span class="s2">                AND sub_class IS null AND class IS null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (ta:Taxonomy </span><span class="se">{{</span><span class="s2"> Name:super_class </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (m)-[:PART_OF_CLADE]-&gt;(ta)</span>
<span class="s2">        )</span>
<span class="s2">        FOREACH(ignoreMe IN CASE WHEN kingdom IS NOT null AND sub_class IS null</span>
<span class="s2">                AND class IS null AND super_class IS null  THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (ta:Taxonomy </span><span class="se">{{</span><span class="s2"> Name:kingdom </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (m)-[:PART_OF_CLADE]-&gt;(ta)</span>
<span class="s2">        )</span>

<span class="s2">        // We add the alternative_parents in the appropriate format</span>

<span class="s2">        FOREACH(element in alternative_parents|</span>
<span class="s2">            FOREACH(taxonomy in element._children|</span>
<span class="s2">                MERGE (t:Taxonomy </span><span class="se">{{</span><span class="s2">Name:taxonomy._text</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">                MERGE (m)-[:PART_OF_CLADE]-&gt;(t)</span>
<span class="s2">            )</span>
<span class="s2">        )</span>

<span class="s2">        // If any Taxonomy is left without a connection, we connect it to the main graph</span>
<span class="s2">        // Beware: if any disconnected taxonomy is left from before, this could lead to errors</span>

<span class="s2">        WITH m, alternative_parents</span>
<span class="s2">        MATCH (tt:Taxonomy) WHERE NOT (tt)--()</span>
<span class="s2">        MERGE (m)-[:PART_OF_CLADE]-&gt;(tt)</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_experimental_properties"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_experimental_properties">[docs]</a><span class="k">def</span> <span class="nf">add_experimental_properties</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds properties to existing &quot;Metabolite&quot; nodes based on XML files obtained from the HMDB website.</span>
<span class="sd">    In this case, only properties labeled as &lt;experimental_properties&gt; are added.</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. NOTE:: Another option would have been to auto-add all the properties, and name them using</span>
<span class="sd">        RETURN &quot;Experimental &quot; + apoc.text.capitalizeAll(replace(kind, &quot;_&quot;, &quot; &quot;)), value; however, this</span>
<span class="sd">        way we can select and not duplicate / overwrite values.</span>

<span class="sd">    .. TODO:: It would be nice to be able to distinguish between experimental and predicted properties</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;metabolite&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;experimental_properties&quot;] AS experimental_properties</span>

<span class="s2">        UNWIND experimental_properties as experimental_property</span>
<span class="s2">        WITH experimental_property, accession</span>
<span class="s2">        UNWIND experimental_property[&quot;_children&quot;] AS my_property</span>
<span class="s2">        WITH my_property, accession</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in my_property._children WHERE X._type = &quot;kind&quot;][0]._text AS kind,</span>
<span class="s2">            [X in my_property._children WHERE X._type = &quot;value&quot;][0]._text AS value,</span>
<span class="s2">            accession</span>

<span class="s2">        MERGE (m:Metabolite </span><span class="se">{{</span><span class="s2">HMDB_ID:accession</span><span class="se">}}</span><span class="s2">)</span>

<span class="s2">        WITH apoc.map.fromLists(collect(kind), collect(value)) AS dict, m</span>
<span class="s2">        SET m.Water_Solubility = dict[&quot;water_solubility&quot;], m.logP = dict[&quot;logp&quot;],</span>
<span class="s2">             m.Melting_Point = dict[&quot;melting_point&quot;], m.Boiling_Point = dict[&quot;boiling_point&quot;]</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_predicted_properties"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_predicted_properties">[docs]</a><span class="k">def</span> <span class="nf">add_predicted_properties</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds properties to existing &quot;Metabolite&quot; nodes based on XML files obtained from the HMDB website.</span>
<span class="sd">    In this case, only properties labeled as &lt;predicted_properties&gt; are added.</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. NOTE:: Another option would have been to auto-add all the properties, and name them using</span>
<span class="sd">        RETURN &quot;Predicted &quot; + apoc.text.capitalizeAll(replace(kind, &quot;_&quot;, &quot; &quot;)), value; however, this</span>
<span class="sd">        way we can select and not duplicate / overwrite values.</span>

<span class="sd">    .. TODO:: It would be nice to be able to distinguish between experimental and predicted properties</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;metabolite&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;predicted_properties&quot;] AS predicted_properties</span>

<span class="s2">        UNWIND predicted_properties as predicted_property</span>
<span class="s2">        WITH predicted_property, accession</span>
<span class="s2">        UNWIND predicted_property[&quot;_children&quot;] AS my_property</span>
<span class="s2">        WITH my_property, accession</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in my_property._children WHERE X._type = &quot;kind&quot;][0]._text AS kind,</span>
<span class="s2">            [X in my_property._children WHERE X._type = &quot;value&quot;][0]._text AS value,</span>
<span class="s2">            accession</span>

<span class="s2">        MERGE (m:Metabolite </span><span class="se">{{</span><span class="s2">HMDB_ID:accession</span><span class="se">}}</span><span class="s2">)</span>

<span class="s2">        WITH apoc.map.fromLists(collect(kind), collect(value)) AS dict, m</span>
<span class="s2">        SET m.Bioavailability = dict[&quot;bioavailability&quot;],</span>
<span class="s2">            m.Donor_Count = dict[&quot;donor_count&quot;],  m.Polar_Surface_Area = dict[&quot;polar_surface_area&quot;],</span>
<span class="s2">            m.Ro5 = dict[&quot;rule_of_five&quot;], m.pKa_Strongest_Acidic = dict[&quot;pka_strongest_acidic&quot;],</span>
<span class="s2">            m.pKa_Strongest_Basic = dict[&quot;pka_strongest_basic&quot;], m.Number_of_Rings = dict[&quot;number_of_rings&quot;],</span>
<span class="s2">            m.Physiological_Charge = dict[&quot;physiological_charge&quot;], m.Polarizability = dict[&quot;polarizability&quot;],</span>
<span class="s2">            m.logS = dict[&quot;logs&quot;], m.MDDR_Like_Rule = dict[&quot;mddr_like_rule&quot;],</span>
<span class="s2">            m.Ghose_Filter = dict[&quot;ghose_filter&quot;], m.Refractivity = dict[&quot;refractivity&quot;],</span>
<span class="s2">            m.Rotatable_Bond_Count = dict[&quot;rotatable_bond_count&quot;], m.Acceptor_Count = dict[&quot;acceptor_count&quot;],</span>
<span class="s2">            m.Formal_Charge = dict[&quot;formal_charge&quot;], m.Verber_Rule = dict[&quot;veber_rule&quot;]</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_biological_properties"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_biological_properties">[docs]</a><span class="k">def</span> <span class="nf">add_biological_properties</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds biological properties to existing &quot;Metabolite&quot; nodes based on XML files obtained from the HMDB website.</span>
<span class="sd">    In this case, only properties labeled as &lt;predicted_properties&gt; are added.</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. NOTE:: Another option would have been to auto-add all the properties, and name them using</span>
<span class="sd">        RETURN &quot;Predicted &quot; + apoc.text.capitalizeAll(replace(kind, &quot;_&quot;, &quot; &quot;)), value; however, this</span>
<span class="sd">        way we can select and not duplicate / overwrite values.</span>

<span class="sd">    .. TODO:: It would be nice to be able to distinguish between experimental and predicted properties</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;metabolite&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;biological_properties&quot;] AS biological_properties</span>

<span class="s2">        MERGE (m:Metabolite </span><span class="se">{{</span><span class="s2">HMDB_ID:accession</span><span class="se">}}</span><span class="s2">)</span>

<span class="s2">        WITH biological_properties, m</span>
<span class="s2">        UNWIND biological_properties AS biological_property</span>
<span class="s2">        WITH biological_property, m</span>
<span class="s2">        UNWIND biological_property[&quot;_children&quot;] AS my_property</span>

<span class="s2">        WITH</span>
<span class="s2">            [X IN my_property._children WHERE X._type = &quot;cellular&quot;] AS cellulars,</span>
<span class="s2">            [X IN my_property._children WHERE X._type = &quot;biospecimen&quot;] AS biospecimens,</span>
<span class="s2">            [X IN my_property._children WHERE X._type = &quot;tissue&quot;] AS tissues,</span>
<span class="s2">            [X IN my_property._children WHERE X._type = &quot;pathway&quot;] AS pathways,</span>
<span class="s2">            m</span>

<span class="s2">        FOREACH(location IN cellulars|</span>
<span class="s2">            MERGE (c:CelularLocation </span><span class="se">{{</span><span class="s2">Name:location._text</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (m)-[r:LOCATED_INSIDE_CELL]-&gt;(c)</span>
<span class="s2">        )</span>
<span class="s2">        FOREACH(location IN biospecimens|</span>
<span class="s2">            MERGE (b:BioSpecimen </span><span class="se">{{</span><span class="s2">Name:location._text</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (m)-[r:LOCATED_IN_BIOSPECIMEN]-&gt;(b)</span>
<span class="s2">        )</span>
<span class="s2">        FOREACH(location IN tissues|</span>
<span class="s2">            MERGE (t:Tissue </span><span class="se">{{</span><span class="s2">Name:location._text</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            MERGE (m)-[r:LOCATED_IN_TISSUE]-&gt;(t)</span>
<span class="s2">        )</span>
<span class="s2">        WITH pathways, m</span>
<span class="s2">        UNWIND pathways as my_pathways</span>
<span class="s2">        WITH my_pathways, m</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in my_pathways._children WHERE X._type = &quot;name&quot;][0]._text AS name,</span>
<span class="s2">            [X in my_pathways._children WHERE X._type = &quot;smpdb_id&quot;][0]._text AS smpdb_id,</span>
<span class="s2">            [X in my_pathways._children WHERE X._type = &quot;kegg_map_id&quot;][0]._text AS kegg_map_id,</span>
<span class="s2">            m</span>

<span class="s2">        MERGE (p:Pathway </span><span class="se">{{</span><span class="s2">Name:name</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">        SET p.SMPDB_ID = smpdb_id, p.KEGG_ID = kegg_map_id</span>
<span class="s2">        MERGE (m)-[r:PART_OF_PATHWAY]-&gt;(p)</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_proteins"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_proteins">[docs]</a><span class="k">def</span> <span class="nf">add_proteins</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates &quot;Protein&quot; nodes based on XML files obtained from the HMDB website.</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. NOTE:: We are not creating &quot;Gene&quot; nodes (even though each protein comes from a given gene)</span>
<span class="sd">        because we believe not enough information is being given about them.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;protein&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;name&quot;][0]._text AS name,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;protein_type&quot;][0]._text AS protein_type,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;gene_name&quot;][0]._text AS gene_name,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;general_function&quot;][0]._text AS general_function,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;specific_function&quot;][0]._text AS specific_function,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;genbank_protein_id&quot;][0]._text AS genbank_protein_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;uniprot_id&quot;][0]._text AS uniprot_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;uniprot_name&quot;][0]._text AS uniprot_name,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;genbank_gene_id&quot;][0]._text AS genbank_gene_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;genecard_id&quot;][0]._text AS genecard_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;geneatlas_id&quot;][0]._text AS geneatlas_id,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;hgnc_id&quot;][0]._text AS hgnc_id,</span>

<span class="s2">            [X in metabolite._children WHERE X._type = &quot;subcellular_locations&quot;] AS subcellular_locations,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;secondary_accessions&quot;] AS secondary_accessions,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;pdb_ids&quot;] AS pdb_ids,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;synonyms&quot;] AS synonyms</span>

<span class="s2">        MERGE (p:Protein </span><span class="se">{{</span><span class="s2"> HMDB_ID:accession </span><span class="se">}}</span><span class="s2"> )</span>
<span class="s2">        SET p.Name = name, p.UniProt_ID = uniprot_id,</span>
<span class="s2">            p.Function = protein_type, p.Gene_Name = gene_name, p.Function = general_function,</span>
<span class="s2">            p.Specific_Function = specific_function, p.Genbank_Protein_ID = genbank_protein_id,</span>
<span class="s2">            p.GenBank_Gene_ID = genbank_gene_id, p.GeneCards_ID = genecard_id,</span>
<span class="s2">            p.GenAtlas_ID = geneatlas_id, p.HGNC_ID = hgnc_id</span>

<span class="s2">        WITH secondary_accessions, synonyms, pdb_ids, subcellular_locations, p</span>

<span class="s2">        FOREACH(element in subcellular_locations|</span>
<span class="s2">            FOREACH(location in element._children|</span>
<span class="s2">                MERGE (c:CelularLocation </span><span class="se">{{</span><span class="s2">Name:location._text</span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">                MERGE (p)-[r:LOCATED_INSIDE_CELL]-&gt;(c)</span>
<span class="s2">            )</span>
<span class="s2">        )</span>

<span class="s2">        SET p.Synonyms = &quot;&quot;, p.Secondary_HMDB_IDs = &quot;&quot;, p.PDB_ID = &quot;&quot;</span>
<span class="s2">        FOREACH(element in secondary_accessions|</span>
<span class="s2">            FOREACH(accession in element._children|</span>
<span class="s2">                SET p.Secondary_HMDB_IDs = accession._text + &quot;,&quot; + p.Secondary_HMDB_IDs</span>
<span class="s2">            )</span>
<span class="s2">        )</span>
<span class="s2">        FOREACH(element in synonyms|</span>
<span class="s2">            FOREACH(synonym in element._children|</span>
<span class="s2">                SET p.Synonyms = synonym._text + &quot;,&quot; + p.Synonyms</span>
<span class="s2">            )</span>
<span class="s2">        )</span>
<span class="s2">        FOREACH(element in pdb_ids|</span>
<span class="s2">            FOREACH(pdb in element._children|</span>
<span class="s2">                SET p.PDB_ID = pdb._text + &quot;,&quot; + p.PDB_ID</span>
<span class="s2">            )</span>
<span class="s2">        )</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_go_classifications"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_go_classifications">[docs]</a><span class="k">def</span> <span class="nf">add_go_classifications</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates &quot;Gene Ontology&quot; nodes based on XML files obtained from the HMDB website.</span>
<span class="sd">    This relates each protein to some GO-Terms</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;protein&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;go_classifications&quot;] AS go_classifications</span>

<span class="s2">        MERGE (p:Protein </span><span class="se">{{</span><span class="s2"> HMDB_ID:accession </span><span class="se">}}</span><span class="s2">)</span>

<span class="s2">        WITH go_classifications, p</span>
<span class="s2">        UNWIND go_classifications AS go_class</span>
<span class="s2">        WITH go_class, p</span>
<span class="s2">        UNWIND go_class[&quot;_children&quot;] AS my_class</span>

<span class="s2">        WITH</span>
<span class="s2">            [X in my_class._children WHERE X._type = &quot;category&quot;][0]._text AS category,</span>
<span class="s2">            [X in my_class._children WHERE X._type = &quot;description&quot;][0]._text AS description,</span>
<span class="s2">            [X in my_class._children WHERE X._type = &quot;go_id&quot;][0]._text AS go_id,</span>
<span class="s2">            p</span>

<span class="s2">        MERGE (g:GeneOntology </span><span class="se">{{</span><span class="s2"> Description:description </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">        SET g.GO_ID = go_id, g.Category = category</span>

<span class="s2">        MERGE (p)-[r:PART_OF_GENE_ONTOLOGY]-(g)</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_gene_properties"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_gene_properties">[docs]</a><span class="k">def</span> <span class="nf">add_gene_properties</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds some properties to existing &quot;Protein&quot; nodes based on XML files obtained from the HMDB website.</span>
<span class="sd">    In this case, properties will mostly relate to the gene from which the protein originates.</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. NOTE:: We are not creating &quot;Gene&quot; nodes (even though each protein comes from a given gene)</span>
<span class="sd">        because we believe not enough information is being given about them.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;protein&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;gene_properties&quot;] AS gene_properties</span>

<span class="s2">        MERGE (p:Protein </span><span class="se">{{</span><span class="s2"> HMDB_ID:accession </span><span class="se">}}</span><span class="s2">)</span>

<span class="s2">        WITH gene_properties, p</span>
<span class="s2">        UNWIND gene_properties AS gene_property</span>

<span class="s2">        WITH</span>
<span class="s2">            [X in gene_property._children WHERE X._type = &quot;chromosome_location&quot;][0]._text AS chromosome_location,</span>
<span class="s2">            [X in gene_property._children WHERE X._type = &quot;locus&quot;][0]._text AS locus,</span>
<span class="s2">            [X in gene_property._children WHERE X._type = &quot;gene_sequence&quot;][0]._text AS gene_sequence,</span>
<span class="s2">            p</span>

<span class="s2">        WITH</span>
<span class="s2">            replace(replace(gene_sequence, split(gene_sequence, &quot;bp&quot;)[0]+&quot;bp&quot;, &quot;&quot;), &quot; &quot;, &quot;&quot;) as SEQUENCE,</span>
<span class="s2">            chromosome_location, locus, gene_sequence, p</span>

<span class="s2">        FOREACH(ignoreMe IN CASE WHEN SEQUENCE IS NOT null AND SEQUENCE &lt;&gt; &quot;&quot; THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (se:Sequence </span><span class="se">{{</span><span class="s2"> Sequence:SEQUENCE </span><span class="se">}}</span><span class="s2"> )</span>
<span class="s2">            SET se.Type= &quot;DNA&quot;, se.Chromosome_Location = chromosome_location, se.Locus = locus</span>
<span class="s2">            MERGE (p)-[r:SEQUENCED_AS]-&gt;(se)</span>
<span class="s2">        )</span>

<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_protein_properties"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_protein_properties">[docs]</a><span class="k">def</span> <span class="nf">add_protein_properties</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds some properties to existing &quot;Protein&quot; nodes based on XML files obtained from the HMDB website.</span>
<span class="sd">    In this case, properties will mostly relate to the protein itself.</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. NOTE:: The &quot;signal_regions&quot; and the &quot;transmembrane_regions&quot; properties were left out</span>
<span class="sd">        because, after a preliminary search, they were mostly empty</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;protein&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;protein_properties&quot;] AS protein_properties,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;uniprot_id&quot;][0]._text AS uniprot_id</span>

<span class="s2">        MERGE (p:Protein </span><span class="se">{{</span><span class="s2"> HMDB_ID:accession </span><span class="se">}}</span><span class="s2">)</span>

<span class="s2">        WITH protein_properties, p, uniprot_id</span>
<span class="s2">        UNWIND protein_properties AS protein_property</span>

<span class="s2">        WITH</span>
<span class="s2">            [X in protein_property._children WHERE X._type = &quot;residue_number&quot;][0]._text AS residue_number,</span>
<span class="s2">            [X in protein_property._children WHERE X._type = &quot;molecular_weight&quot;][0]._text AS molecular_weight,</span>
<span class="s2">            [X in protein_property._children WHERE X._type = &quot;theoretical_pi&quot;][0]._text AS theoretical_pi,</span>
<span class="s2">            [X in protein_property._children WHERE X._type = &quot;pfams&quot;] AS pfams,</span>
<span class="s2">            [X in protein_property._children WHERE X._type = &quot;polypeptide_sequence&quot;][0]._text AS polypeptide_sequence,</span>
<span class="s2">            p, uniprot_id</span>

<span class="s2">        SET p.Residue_Number = residue_number, p.Molecular_Weight = molecular_weight,</span>
<span class="s2">            p.Theoretical_PI = theoretical_pi</span>

<span class="s2">        FOREACH(ignoreMe IN CASE WHEN polypeptide_sequence IS NOT null AND polypeptide_sequence &lt;&gt; &quot;&quot; THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (se:Sequence </span><span class="se">{{</span><span class="s2"> Sequence: polypeptide_sequence </span><span class="se">}}</span><span class="s2"> )</span>
<span class="s2">            SET se.Type= &quot;PROT&quot;, se.UniProt_ID = uniprot_id</span>
<span class="s2">            MERGE (p)-[r:SEQUENCED_AS]-&gt;(se)</span>
<span class="s2">        )</span>


<span class="s2">        WITH p, pfams</span>
<span class="s2">        UNWIND pfams AS pfam</span>
<span class="s2">        WITH p, pfam</span>
<span class="s2">        UNWIND pfam[&quot;_children&quot;] AS my_pfam</span>

<span class="s2">        WITH</span>
<span class="s2">            [X in my_pfam._children WHERE X._type = &quot;name&quot;][0]._text AS name,</span>
<span class="s2">            [X in my_pfam._children WHERE X._type = &quot;pfam_id&quot;][0]._text AS pfam_id,</span>
<span class="s2">            p</span>

<span class="s2">        MERGE (pf:PFam </span><span class="se">{{</span><span class="s2"> PFAM_ID:pfam_id </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">        SET pf.Name = name</span>
<span class="s2">        MERGE (p)-[r:PART_OF_PFAM]-&gt;(pf)</span>

<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_general_references"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_general_references">[docs]</a><span class="k">def</span> <span class="nf">add_general_references</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">type_of</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates &quot;Publication&quot; nodes based on XML files obtained from the HMDB website.</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. NOTE:: Since not all nodes present a &quot;PubMed_ID&quot; field (which would be ideal to uniquely-identify</span>
<span class="sd">        Publications, as the &quot;Text&quot; field is way more prone to typos/errors), nodes will be created using</span>
<span class="sd">        the &quot;Authors&quot; field. This means some duplicates might exist, which should be accounted for.</span>

<span class="sd">    .. NOTE:: Unlike the rest, here we are not matching metabolites, but ALSO proteins. This is intentional.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;</span><span class="si">{</span><span class="n">type_of</span><span class="si">}</span><span class="s2">&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;general_references&quot;] AS general_references</span>

<span class="s2">        MATCH (m) WHERE (m:Metabolite OR m:Protein) AND m.HMDB_ID = accession</span>

<span class="s2">        WITH general_references, m</span>
<span class="s2">        UNWIND general_references AS general_reference</span>
<span class="s2">        WITH general_reference, m</span>
<span class="s2">        UNWIND general_reference[&quot;_children&quot;] AS my_reference</span>

<span class="s2">        WITH</span>
<span class="s2">            [X in my_reference._children WHERE X._type = &quot;reference_text&quot;][0]._text AS reference_text,</span>
<span class="s2">            [X in my_reference._children WHERE X._type = &quot;pubmed_id&quot;][0]._text AS pubmed_id,</span>
<span class="s2">            m</span>

<span class="s2">        WITH split(replace(reference_text, split(reference_text, &quot;:&quot;)[0]+&quot;: &quot;, &quot;&quot;), &quot;.&quot;)[0] AS ref_title,</span>
<span class="s2">             pubmed_id, reference_text, m</span>
<span class="s2">        FOREACH(ignoreMe IN CASE WHEN ref_title IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (p:Publication </span><span class="se">{{</span><span class="s2"> Title: ref_title </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            SET p.Authors = split(reference_text, &quot;:&quot;)[0]</span>


<span class="s2">            SET p.Publication = split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[0]</span>
<span class="s2">            SET p.Notes = split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[2]</span>
<span class="s2">            SET p.Date = split(split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[1],&quot;;&quot;)[0]</span>
<span class="s2">            SET p.Volume = split(split(reference_text, &quot;;&quot;)[1], &quot;(&quot;)[0]</span>
<span class="s2">            SET p.Issue = split(split(reference_text, &quot;(&quot;)[1], &quot;)&quot;)[0]</span>
<span class="s2">            SET p.Pages = split(split(reference_text, &quot;:&quot;)[-1], &quot;.&quot;)[0]</span>
<span class="s2">            SET p.PubMed_ID = pubmed_id</span>

<span class="s2">            MERGE (m)-[r:CITED_IN]-&gt;(p)</span>
<span class="s2">        )</span>

<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_protein_associations"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_protein_associations">[docs]</a><span class="k">def</span> <span class="nf">add_protein_associations</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates &quot;Protein&quot; nodes based on XML files obtained from the HMDB website.</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. NOTE:: Unlike the &quot;add_protein&quot; function, this creates Proteins based on info on the</span>
<span class="sd">        &quot;Metabolite&quot; files, not on the &quot;Protein&quot; files themselves. This could mean node duplication, but,</span>
<span class="sd">        hopefully, the MERGE by Accession will mean that this duplicates will be catched.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;metabolite&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;protein_associations&quot;] AS protein_associations</span>

<span class="s2">        MERGE (m:Metabolite </span><span class="se">{{</span><span class="s2">HMDB_ID:accession</span><span class="se">}}</span><span class="s2">)</span>

<span class="s2">        WITH protein_associations, m</span>
<span class="s2">        UNWIND protein_associations AS protein_association</span>
<span class="s2">        WITH protein_association, m</span>
<span class="s2">        UNWIND protein_association[&quot;_children&quot;] AS my_protein</span>

<span class="s2">        WITH</span>
<span class="s2">            [X in my_protein._children WHERE X._type = &quot;protein_accession&quot;][0]._text AS protein_accession,</span>
<span class="s2">            [X in my_protein._children WHERE X._type = &quot;name&quot;][0]._text AS name,</span>
<span class="s2">            [X in my_protein._children WHERE X._type = &quot;uniprot_id&quot;][0]._text AS uniprot_id,</span>
<span class="s2">            [X in my_protein._children WHERE X._type = &quot;gene_name&quot;][0]._text AS gene_name,</span>
<span class="s2">            [X in my_protein._children WHERE X._type = &quot;protein_type&quot;][0]._text AS protein_type,</span>
<span class="s2">            m</span>

<span class="s2">        MERGE (p:Protein </span><span class="se">{{</span><span class="s2"> HMDB_ID:protein_accession </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">        ON CREATE SET p.Gene_Name = gene_name, p.Function = protein_type,</span>
<span class="s2">                      p.UniProt_ID = uniprot_id, p.Name = name</span>

<span class="s2">        MERGE (m)-[r:INTERACTS_WITH]-(p)</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_metabolite_associations"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_metabolite_associations">[docs]</a><span class="k">def</span> <span class="nf">add_metabolite_associations</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds associations contained in the &quot;protein&quot; file, between proteins and metabolites.</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. NOTE:: Like he &quot;add_metabolite_associations&quot; function, this creates non-directional</span>
<span class="sd">        relationships (m)-[r:ASSOCIATED_WITH]-(p) ; this helps duplicates be detected.</span>

<span class="sd">    .. NOTE:: The &quot;ON CREATE SET&quot; clause for the &quot;Name&quot; param ensures no overwriting</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;protein&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;metabolite_associations&quot;] AS metabolite_associations</span>

<span class="s2">        MERGE (p:Protein </span><span class="se">{{</span><span class="s2"> HMDB_ID:accession </span><span class="se">}}</span><span class="s2">)</span>

<span class="s2">        WITH metabolite_associations, p</span>
<span class="s2">        UNWIND metabolite_associations AS metabolite_association</span>
<span class="s2">        WITH metabolite_association, p</span>
<span class="s2">        UNWIND metabolite_association[&quot;_children&quot;] AS my_metabolite</span>

<span class="s2">        WITH</span>
<span class="s2">            [X in my_metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS metabolite_accession,</span>
<span class="s2">            [X in my_metabolite._children WHERE X._type = &quot;name&quot;][0]._text AS name,</span>
<span class="s2">            p</span>

<span class="s2">        MERGE (m:Metabolite </span><span class="se">{{</span><span class="s2"> HMDB_ID:metabolite_accession </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">        ON CREATE SET m.Name = name</span>

<span class="s2">        MERGE (m)-[r:INTERACTS_WITH]-(p)</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_metabolite_references"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.add_metabolite_references">[docs]</a><span class="k">def</span> <span class="nf">add_metabolite_references</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates references for relations betweens Protein nodes and Metabolite nodes</span>

<span class="sd">    Args:</span>
<span class="sd">        tx          (neo4j.Session): The session under which the driver is running</span>
<span class="sd">        filename    (str): The name of the XML file that is being imported</span>

<span class="sd">    Returns:</span>
<span class="sd">        neo4j.Result: A Neo4J connexion to the database that modifies it according to the CYPHER statement contained in the function.</span>

<span class="sd">    .. WARNING:: Unfortunately, Neo4J makes it really, really, really difficult to work with XML,</span>
<span class="sd">        and so, this time, a r.PubMed_ID list with the references could not be created. Nonetheless,</span>
<span class="sd">        I considered adding this useful.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        CALL apoc.load.xml(&quot;file:///</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;)</span>
<span class="s2">        YIELD value</span>
<span class="s2">        WITH [x in value._children WHERE x._type = &quot;protein&quot;] AS metabolites</span>
<span class="s2">        UNWIND metabolites AS metabolite</span>
<span class="s2">        WITH</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;accession&quot;][0]._text AS accession,</span>
<span class="s2">            [X in metabolite._children WHERE X._type = &quot;metabolite_references&quot;] AS metabolite_references</span>

<span class="s2">        MERGE (p:Protein </span><span class="se">{{</span><span class="s2"> HMDB_ID:accession </span><span class="se">}}</span><span class="s2">)</span>

<span class="s2">        WITH metabolite_references, p</span>
<span class="s2">        UNWIND metabolite_references AS metabolite_reference</span>
<span class="s2">        WITH metabolite_reference, p</span>
<span class="s2">        UNWIND metabolite_reference[&quot;_children&quot;] AS my_reference</span>
<span class="s2">        WITH my_reference, p</span>
<span class="s2">        UNWIND my_reference[&quot;_children&quot;] AS my_ref</span>

<span class="s2">        WITH</span>
<span class="s2">            [X in my_ref._children WHERE X._type = &quot;accession&quot;][0]._text AS metabolite_accession,</span>
<span class="s2">            [X in my_ref._children WHERE X._type = &quot;name&quot;][0]._text AS name,</span>
<span class="s2">            [X in my_ref._children WHERE X._type = &quot;reference_text&quot;][0]._text AS reference_text,</span>
<span class="s2">            [X in my_ref._children WHERE X._type = &quot;pubmed_id&quot;][0]._text AS pubmed_id,</span>
<span class="s2">            p</span>

<span class="s2">        FOREACH(ignoreMe IN CASE WHEN metabolite_accession IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (m:Metabolite </span><span class="se">{{</span><span class="s2"> HMDB_ID:metabolite_accession </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            ON CREATE SET m.name = name</span>
<span class="s2">            MERGE (m)-[r:INTERACTS_WITH]-(p)</span>
<span class="s2">            )</span>

<span class="s2">        WITH split(replace(reference_text, split(reference_text, &quot;:&quot;)[0]+&quot;: &quot;, &quot;&quot;), &quot;.&quot;)[0] AS ref_title,</span>
<span class="s2">             pubmed_id, reference_text, p</span>
<span class="s2">        FOREACH(ignoreMe IN CASE WHEN ref_title IS NOT null THEN [1] ELSE [] END |</span>
<span class="s2">            MERGE (pu:Publication </span><span class="se">{{</span><span class="s2"> Title: ref_title </span><span class="se">}}</span><span class="s2">)</span>
<span class="s2">            SET pu.Authors = split(reference_text, &quot;:&quot;)[0]</span>

<span class="s2">            SET pu.Publication = split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[0]</span>
<span class="s2">            SET pu.Notes = split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[2]</span>
<span class="s2">            SET pu.Date = split(split(replace(reference_text, split(reference_text, &quot;.&quot;)[0]+&quot;. &quot;,&quot;&quot;), &quot;.&quot;)[1],&quot;;&quot;)[0]</span>
<span class="s2">            SET pu.Volume = split(split(reference_text, &quot;;&quot;)[1], &quot;(&quot;)[0]</span>
<span class="s2">            SET pu.Issue = split(split(reference_text, &quot;(&quot;)[1], &quot;)&quot;)[0]</span>
<span class="s2">            SET pu.Pages = split(split(reference_text, &quot;:&quot;)[-1], &quot;.&quot;)[0]</span>
<span class="s2">            SET pu.PubMed_ID = pubmed_id</span>

<span class="s2">            MERGE (p)-[r:CITED_IN]-&gt;(pu)</span>
<span class="s2">        )</span>

<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="build_from_protein_file"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.build_from_protein_file">[docs]</a><span class="k">def</span> <span class="nf">build_from_protein_file</span><span class="p">(</span><span class="n">newfile</span><span class="p">,</span> <span class="n">driver</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function able to build a portion of the HMDB database in graph format, provided that one &quot;Protein&quot; XML is supplied to it.</span>
<span class="sd">    This are downloaded separately from the website, as ```hmdb_proteins.zip```, and can be presented either as the full file,</span>
<span class="sd">    or as a splitted version of it, with just one item per file (which is recommended due to memory limitations)</span>

<span class="sd">    Args:</span>
<span class="sd">        newfile         (str): The path of the XML file to import</span>
<span class="sd">        driver (neo4j.Driver): Neo4J&#39;s Bolt Driver currently in use</span>

<span class="sd">    Returns:</span>
<span class="sd">        This function modifies the Neo4J Database as desired, but does not produce any particular return.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_proteins</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_go_classifications</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_gene_properties</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_protein_properties</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_metabolite_associations</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_metabolite_references</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_general_references</span><span class="p">(</span><span class="n">newfile</span><span class="p">,</span> <span class="s2">&quot;protein&quot;</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span></div>


<div class="viewcode-block" id="build_from_metabolite_file"><a class="viewcode-back" href="../../../CanGraph.GraphifyHMDB.html#CanGraph.GraphifyHMDB.build_database.build_from_metabolite_file">[docs]</a><span class="k">def</span> <span class="nf">build_from_metabolite_file</span><span class="p">(</span><span class="n">newfile</span><span class="p">,</span> <span class="n">driver</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function able to build a portion of the HMDB database in graph format, provided that one &quot;Metabolite&quot; XML is supplied to it.</span>
<span class="sd">    This are downloaded separately from the website, as all the files that are not ```hmdb_proteins.zip```, and can be presented either</span>
<span class="sd">    as the full file, or as a splitted version of it, with just one item per file (which is recommended due to memory limitations)</span>

<span class="sd">    Args:</span>
<span class="sd">        newfile         (str): The path of the XML file to import</span>
<span class="sd">        driver (neo4j.Driver): Neo4J&#39;s Bolt Driver currently in use</span>

<span class="sd">    Returns:</span>
<span class="sd">        This function modifies the Neo4J Database as desired, but does not produce any particular return.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_metabolites</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_protein_associations</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_diseases</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_concentrations_normal</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_concentrations_abnormal</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_taxonomy</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_biological_properties</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_experimental_properties</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_predicted_properties</span><span class="p">(</span><span class="n">newfile</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span>
    <span class="n">misc</span><span class="o">.</span><span class="n">manage_transaction</span><span class="p">(</span><span class="n">add_general_references</span><span class="p">(</span><span class="n">newfile</span><span class="p">,</span> <span class="s2">&quot;metabolite&quot;</span><span class="p">),</span> <span class="n">driver</span><span class="p">)</span></div>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Pablo Marcos<br/>
  
      &copy; Copyright 2022, Pablo Marcos &lt;software@loreak.org&gt;.<br/>
    Last updated on Dec 17, 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>